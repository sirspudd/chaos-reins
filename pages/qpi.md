---
layout: page
title: QPi
permalink: /qpi/
---

# Index

* [Introduction](#introduction)
* [Project Status](#project-status)
* [AUR recipes](#aur-recipes)
* [Arch repo](#arch-repo)
* [Instructions](#instructions)

# Overview

QPi is an attempt to create a convenient [Qt](https://www.qt.io/) SDK for the Raspberry Pi 0/1/2/3 on Arch Linux. You click a button in Qt Creator, your application is automagically deployed and run on the board, without X11 involvement. (The tooling facilitates this, this is primarily a packaging initiative with a little polish required)

# Introduction

<iframe width="560" height="315" src="https://www.youtube.com/embed/vNMQMlucKco" frameborder="0" allowfullscreen></iframe>

The primary goal is to ensure full functionality of Qt on the Raspberry Pi, and to ease the overhead/complexity of cross compilation from desktop Arch installs to Arch based Raspberry Pis.

Qt can run quite nicely on the Pi(s), as long as you are not running it under Xorg/X11. The packaged versions of Qt run the gamut, but I have yet to see a Qt packaging which targets kms/console usage, or which has functional wayland support (outside of Intel hardware) as shipped.

I happen to be a big fan of cross compilation rather than compilation on target, which simply removes all joy from iterative development. We provide 2 packages, one for the Raspberry Pi and one for the host machine, which once installed allow you to cross compile for the Raspberry Pi from your Arch host machine. These packages are simply tar balls, so they should even run outside of Arch in a suitably modern Linux install. (The packaging is frosting)

# Project Status

* Qt 5.10.0 is fully functional on the Raspberry Pi 1/2/3 and the Tinkerboard
* CEC input support is currently alpha
* I personally primarily develop against aarch64 which is now perfectly functional against the vc4 OSS driver

# Known issues

* VIP: if you are using the vc4 open source driver you _have_ to explicity disable the warning overlay, or the warnings trash your screen state and leave you debugging some seriously shit problems. Add avoid_warnings=2 to /boot/confix.txt on aarch64
* One step is required to get remote deployment working: navigate to Tools/Options/Devices/Devices. Select Raspberry Pi # from the drop down, adjust the password as necessary and then hit the test button. Deployment will not work until you hit test, even if all the parameters are correct.
* You need the rootfs to be available at the appropriate location. Welcome to cross compiling. Either copy it to your compile host, or compile against an nfs mount of your Raspberry Pi. Mounting the rootfs ("/") of your Raspberry Pi 2 to /mnt/pi2 (via NFS) does the task nicely.
* Single applications can run well with eglfs at 1080p. I have not been able to get wayland working well on the Raspberry Pi at anything other than 720p.
* Allocate lots of graphical memory if you intend to run GLES2 apps. I allocate 512 MB on the Raspberry Pi 2 and 256 MB on the Pi Zero.
    * this involves adjusting config.txt against the binary driver
    * -or- adding cma=512M@256M to your kernel cmdline (/boot/boot.txt on Arch aarch64)

# Packaging choices

* Excluded Qt WebEngine (not a point of personal interest)
* Excluded Qt Script (legacy)

build from AUR if you want/need this functionality.

# Platform Notes

## Raspberry Pi 0/1(armv6)2/3(armv7)

uses the vc stack and the propietary drivers/blobs (and has CEC support). 2 Packages split along architectual lines.

## Raspberry Pi 3 (aarch64)

uses the mesa stack.

# AUR recipes

These [AUR recipe(s)](https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=qt-sdk-raspberry-pi) are used to generate my Qt SDK packages

# Arch repo

```
[qpi]
SigLevel = Optional
Server = http://s3.amazonaws.com/spuddrepo/repo/$arch
```

This repo is equipped with packages generated by the above recipe, packages you can either directly consume, or ingest by way of magical (read dangerous) bash scripts which you can embrace in disdain for your sovereignty. Proceed at your own risk, and neither myself nor my employer provide any binding guarantees or assurances. Kiss your poodle goodbye.

# Instructions

0. Proceed at your own risk
0. [Install the appropriate Arch on a fresh sd card](https://archlinuxarm.org/platforms/armv7/broadcom/raspberry-pi-2)
0. Boot the Raspberry Pi
0. Download and run the following [script](https://raw.githubusercontent.com/sirspudd/sirspudd.github.io/master/scripts/setup_qpi.sh) on the RPI
0. I personally normally do this by allowing root login via ssh and then grabbing the script via curl
0. curl http://www.chaos-reins.com/scripts/setup_qpi.sh > setup_qpi.sh
0. bash setup_qpi.sh
0. I would strongly recommend increasing the video ram to 512 in /boot/config.txt. When using the mesa stack (The Pi 3) the contents of config.txt are ignored, and you have to stipulate the graphical memory via a kernel commandline argument: cma=512
0. Run this [script](http://www.chaos-reins.com/scripts/setup_qpi_host.sh) on your Arch host machine
0. Mount your Arch sysroot on your host (recommend NFS, mounting "/" under /mnt/pi{version})
0. You are now set to use Qt Creator to develop and deploy to your Raspberry Pi
0. Please note, you might have to explicitly "test" the device in the device page of Qt Creator in order for deployment to work. (pessimistic)
