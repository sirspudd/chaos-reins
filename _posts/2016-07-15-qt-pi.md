---
layout: post
title:  "Using the distro packaged Qt with Arch Linux and VC4 on the Raspberry Pi 2/3"
date:   2016-07-13 12:10:59 -0700
published: true
tags: [qt, pi, embedded, gl, arch linux, linux, oss]
---

# Background

I have been packaging Qt for the Raspberry Pi for some months now as documented [here](/qpi). The motivation behind packaging it is that the distro provided Qt versions were compiled against Mesa, not against the proprietary drivers. This resulted in abysmal performance, especially on the Raspberry Pi 1/0, and especially at relatively high resolutions like 1080p. With the broad adoption of the opensource VC4 driver, we can suddenly harness the distro packaged Qt versions, which on Arch Linux tend to be 1-2 weeks behind official Qt releases. Mesa is also awfully current, which is valuable since we want the latest VC4 changes.

# Process

1. Set up Arch for your respective Pi
  * https://archlinuxarm.org/platforms/armv6/raspberry-pi#installation
  * https://archlinuxarm.org/platforms/armv7/broadcom/raspberry-pi-2#installation
2. Boot your system
3. Set up networking (wired is trivial; wifi-menu makes wpa_supplicant idiot proof)
4. Update it using: pacman -Syu
5. pacman -S base-devel qt5 git (Required for building)
6. Adjust your system to boot use the VC4 driver by adjusting config.txt to contain:

        avoid_warnings=2     # VPU shouldn't smash our display setup.
        dtoverlay=vc4-kms-v3d

7. Adjust cmdline.txt by appending the following to the existing kernel command line:

        cma=256M@256M

8. Reboot your device
9. Qt applications can now be run with the EGLFS plugin provided at runtime. So what can we use/see in order to see the performance of Qt? I personally favour:

        https://github.com/qml-box2d/qml-box2d

which needs to be built from source. Easy enough:

        git clone https://github.com/qml-box2d/qml-box2d.git
        qmake
        make
        make install

change into ./examples in the code and you can now run all the examples:

        qmlscene -platform eglfs cannon/main.qml

As you will see, things run swimmingly at 1080p and your attached mouse/keyboard simply works by virtue of libinput. No Xorg/X11, no worries, and this is peak performance. It will fall through a hole in the floor if you need multiple surfaces, like cool-retro-term (or any more sophisticated app) for instance. In these circumstances, we are better off using Wayland.
10. The next step is logically to see how Wayland works
11. Both Qt compositors and weston barf when Qt clients are run with -platform wayland

        [root@alarmpi ~]# qmlscene ~/moo.qml -platform wayland
        Using Wayland-EGL
        Attempting to import 506x533 b8g8r8a8_unorm with unsupported stride 2032 instead of 128
        wl_drm@17: error 2: invalid name

This problem did not exist in the Qt 5.7 builds I produced against Mesa. (Although as of the Qt 5.7 final release, the proprietary wayland backend is exploding rather spectacularly. (But did not do so as of the Qt 5.7 alpha)) weston-terminal launches correctly, so the point of failure is localized to the packaged Qt. Rebuilding qtwayland does not resolve anything, and I suspect this boils down to the surface management helper functionality built into Qt.

* * *

This actually constitutes a deal breaker for me. Without wayland, we have something which is good for dedicated applications whose code base we control, but we can't simply point hobbyists and other people who consume other peoples code (the vast majority of Linux users) at this and have them go to town doing cool stuff with Qt on the Pi. I am gonna focus on getting the QPi packages back up to spec against the proprietary drivers.

# TL&DR

| Flavour | OpenGL ES 2 | EGLFS | Wayland | [QCEC*](https://github.com/sirspudd/qcec) | 
| :---: | :---: | :---: | :---: | :---: |
| Arch Packaged | y | y | n | n |
| QPi | y | y | n | y |

\* Require's Dispmanx support as per libcec
